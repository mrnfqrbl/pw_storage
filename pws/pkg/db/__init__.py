# 文件路径: src/pkg/db/数据库总线适配.py
# 中文说明：
# 数据库总线适配器模块
# 将数据库接口操作通过事件总线暴露给上层业务，实现解耦
# 增强事件处理完整性，支持数据集、文档、索引的操作事件

import datetime
from typing import Any, Dict, cast, List, Tuple

from pws.app.core.公共类型定义.事件对象模型 import 总线通用事件模型
from pws.app.core.公共类型定义.函数通用返回模型 import 函数通用返回模型
from pws.app.core.公共类型定义.数据库接口 import 数据库接口
from pws.app.core.公共类型定义.数据库文档模型 import 文档模型, 历史记录模型


class 数据库总线适配器:
    """
    数据库总线适配器
    将数据库接口操作封装成事件调用，解耦业务模块与数据库实现
    """

    def __init__(self, 数据库实例: 数据库接口, 总线: Any):
        """
        :param 数据库实例: 实现了数据库接口的数据库对象
        :param 总线: 支持订阅/发布的事件总线对象
        """
        self.数据库: 数据库接口 = 数据库实例
        self.总线 = 总线
        self._注册数据库事件()
        self.总线.发布日志("info", f"数据库总线适配器初始化完成，数据库名称：{self.数据库.数据库名}")

    def 生成回调结果(self, 事件: 总线通用事件模型, 函数调用返回: 函数通用返回模型):
        """
        生成数据库操作事件的回调结果
        :param 事件: 触发的事件对象
        :param 函数调用返回: 数据库接口返回的函数通用返回模型
        """
        返回结果 = 事件.事件返回.get("数据库适配器", None)
        if 返回结果 is None:
            return
        返回结果.开始时间 = datetime.datetime.now()
        返回结果.数据 = 函数调用返回.数据
        返回结果.状态 = 函数调用返回.状态
        返回结果.错误信息 = 函数调用返回.错误信息
        返回结果.结束时间 = datetime.datetime.now()
        返回结果.订阅者处理耗时 = (返回结果.结束时间 - 返回结果.开始时间).total_seconds()

    def _注册数据库事件(self):
        """
        注册数据库操作事件到总线
        事件名称规则: db.{操作}.{数据集名称/文档/索引}
        """
        # 数据集事件
        self.总线.订阅("db.创建数据集", "数据库适配器", self._事件_创建数据集)
        self.总线.订阅("db.删除数据集", "数据库适配器", self._事件_删除数据集)
        self.总线.订阅("db.获取数据集列表", "数据库适配器", self._事件_获取数据集列表)
        self.总线.订阅("db.获取业务数据集列表", "数据库适配器", self._事件_获取业务数据集列表)
        self.总线.订阅("db.重命名数据集", "数据库适配器", self._事件_重命名数据集)




        # 文档事件
        self.总线.订阅("db.插入文档", "数据库适配器", self._事件_插入文档)
        self.总线.订阅("db.查询文档", "数据库适配器", self._事件_查询文档)
        self.总线.订阅("db.更新文档", "数据库适配器", self._事件_更新文档)
        self.总线.订阅("db.删除文档", "数据库适配器", self._事件_删除文档)

        # 索引事件
        self.总线.订阅("db.创建索引", "数据库适配器", self._事件_创建索引)
        self.总线.订阅("db.删除索引", "数据库适配器", self._事件_删除索引)

        # 辅助事件
        self.总线.订阅("db.获取合集文档最大序号", "数据库适配器", self._事件_获取合集文档最大序号)

    # ---------------- 数据集操作事件回调 ----------------
    def _事件_创建数据集(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        数据集名称 = 数据.get("数据集名称")
        if not 数据集名称:
            self.生成回调结果(事件, 函数通用返回模型(
                状态=函数通用返回模型.失败,
                错误信息="创建数据集事件缺失数据集名称参数"
            ))
            self.总线.发布日志("error", f"事件ID:{事件.事件uuid}，缺失数据集名称参数")
            return
        函数返回 = self.数据库.创建数据集(cast(str, 数据集名称))
        self.生成回调结果(事件, 函数返回)

    def _事件_删除数据集(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        数据集名称 = 数据.get("数据集名称")
        if not 数据集名称:
            self.生成回调结果(事件, 函数通用返回模型(
                状态=函数通用返回模型.失败,
                错误信息="删除数据集事件缺失数据集名称参数"
            ))
            self.总线.发布日志("error", f"事件ID:{事件.事件uuid}，缺失数据集名称参数")
            return
        函数返回 = self.数据库.删除数据集(cast(str, 数据集名称))
        self.生成回调结果(事件, 函数返回)
    def _事件_重命名数据集(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        数据集名称 = 数据.get("数据集名称")
        新数据集名称 = 数据.get("新数据集名称")
        if not 数据集名称 or not 新数据集名称:
            self.生成回调结果(事件, 函数通用返回模型(
                状态=函数通用返回模型.失败,
                错误信息="重命名数据集事件缺失数据集名称或新数据集名称参数"
            ))
            self.总线.发布日志("error", f"事件ID:{事件.事件uuid}，缺失参数:数据集名称或新数据集名称")
            return
        函数返回 = self.数据库.重命名数据集(cast(str, 数据集名称), cast(str, 新数据集名称))
        self.生成回调结果(事件, 函数返回)
    def _事件_获取数据集列表(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        函数返回 = self.数据库.获取数据集列表()
        self.生成回调结果(事件, 函数返回)
    def _事件_获取业务数据集列表(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        函数返回 = self.数据库.获取数据集列表()
        数据集列表=函数返回.数据
        #返回列表排除_历史记录相关合集和数据集配置汇总名称的合集
        业务数据集列表 = [
            数据集
            for 数据集 in 数据集列表
            if not 数据集.endswith("_历史记录") and 数据集 != "数据集配置汇总"
        ]
        函数返回.数据=业务数据集列表
        self.生成回调结果(事件, 函数返回)
    # ---------------- 文档操作事件回调 ----------------
    def _事件_插入文档(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        数据集名称 = 数据.get("数据集名称")
        文档数据 = 数据.get("文档数据")
        if not 数据集名称 or not 文档数据:
            self.生成回调结果(事件, 函数通用返回模型(
                状态=函数通用返回模型.失败,
                错误信息="插入文档事件缺失数据集名称或文档数据参数"
            ))
            self.总线.发布日志("error", f"事件ID:{事件.事件uuid}，缺失参数")
            return

        #如果文档数据对象存在转字典方法，调用转换为字典
        if hasattr(文档数据, "转字典"):
            文档数据=文档数据.转字典()
        #如果文档是其他类型，直接返回错误
        if not isinstance(文档数据, dict):
            self.生成回调结果(事件, 函数通用返回模型(
                状态=函数通用返回模型.失败,
                错误信息="插入文档事件文档数据参数必须是字典类型"
            ))
            self.总线.发布日志("error", f"事件ID:{事件.事件uuid}，文档数据参数必须是字典类型")
            return
        函数返回 = self.数据库.插入文档(cast(str, 数据集名称), cast(dict, 文档数据))
        self.生成回调结果(事件, 函数返回)

    def _事件_查询文档(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        数据集名称 = 数据.get("数据集名称")
        查询条件 = 数据.get("查询条件", {})
        投影 = 数据.get("投影")
        排序 = 数据.get("排序")
        限制 = 数据.get("限制")
        if not 数据集名称:
            self.生成回调结果(事件, 函数通用返回模型(
                状态=函数通用返回模型.失败,
                错误信息="查询文档事件缺失数据集名称参数"
            ))
            self.总线.发布日志("error", f"事件ID:{事件.事件uuid}，缺失数据集名称参数")
            return
        函数返回 = self.数据库.查询文档(
            cast(str, 数据集名称),
            cast(dict, 查询条件),
            cast(dict, 投影) if 投影 else None,
            cast(List[Tuple[str, int]], 排序) if 排序 else None,
            cast(int, 限制) if 限制 else None
        )

        返回数据=函数返回.数据.get("文档列表")
        #从文档列表中将每个字典转换为文档模型

        #如果数据集名称结尾是_历史记录，不转换为文档模型
        if 数据集名称.endswith("_历史记录"):
            for doc in 返回数据:
                print(f"doc:{doc}")
            函数返回.数据["文档列表"] = [历史记录模型(**doc) for doc in 返回数据]

        else:
            函数返回.数据["文档列表"] = [文档模型(**doc) for doc in 返回数据]

        self.总线.发布日志("info", f"事件ID:{事件.事件uuid}，输入数据:{数据}，返回数据={返回数据}，转模型后文档：{函数返回.数据.get('文档列表')}")
        self.生成回调结果(事件, 函数返回)

    def _事件_更新文档(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        数据集名称 = 数据.get("数据集名称")
        查询条件 = 数据.get("查询条件")
        更新文档 = 数据.get("更新内容")
        多条 = 数据.get("多条", False)
        更新文档=更新文档.转字典()
        #去除值为 “空” ”空白“ None null 等相关空值的字段
        def 递归删除并展平字段(数据, parent_key="", 空值集合=None):
            """
            递归删除空字段，并将嵌套字典展平成点号形式
            参数：
                数据: dict 或 list，输入字典/列表
                parent_key: str，递归父键前缀
                空值集合: set，定义哪些值算作空
            返回：
                dict，展平后的字典
            """
            if 空值集合 is None:
                空值集合 = {None, "", " ", "null", "none", "None", "空", "空白"}

            展平结果 = {}

            if isinstance(数据, dict):
                for k, v in 数据.items():
                    # 拼接完整键
                    new_key = f"{parent_key}.{k}" if parent_key else k

                    # 判断空值
                    def 是空值(v):
                        """判断是否为空值"""
                        if v is None:
                            return True
                        if isinstance(v, str) and v.strip().lower() in ["", "null", "none", "空", "空白"]:
                            return True
                        return False
                    if 是空值(v):
                        continue  # 空值直接跳过

                    # 递归处理字典
                    elif isinstance(v, dict):
                        子结果 = 递归删除并展平字段(v, new_key, 空值集合)
                        展平结果.update(子结果)  # 合并子结果

                    # 递归处理列表
                    elif isinstance(v, list):
                        for idx, 项 in enumerate(v):
                            if isinstance(项, dict):
                                子结果 = 递归删除并展平字段(项, f"{new_key}[{idx}]", 空值集合)
                                展平结果.update(子结果)
                            else:
                                if 项 not in 空值集合:
                                    展平结果[f"{new_key}[{idx}]"] = 项
                    else:
                        展平结果[new_key] = v

            elif isinstance(数据, list):
                for idx, 项 in enumerate(数据):
                    子结果 = 递归删除并展平字段(项, f"{parent_key}[{idx}]", 空值集合)
                    展平结果.update(子结果)

            return 展平结果
        结果= 递归删除并展平字段(更新文档)
        print(f"展平嵌套字典后更新文档：{结果}")




        self.总线.发布日志("info", f"事件ID:{事件.事件uuid}，更新文档事件参数：数据集名称={数据集名称}，查询条件={查询条件}，更新内容={结果}，多条={多条}")
        if not 数据集名称 or not 查询条件 or not 结果:
            self.生成回调结果(事件, 函数通用返回模型(
                状态=函数通用返回模型.失败,
                错误信息="更新文档事件缺失必要参数"
            ))
            self.总线.发布日志("error", f"事件ID:{事件.事件uuid}，缺失参数")
            return
        函数返回 = self.数据库.更新文档(
            cast(str, 数据集名称),
            cast(dict, 查询条件),
            cast(dict, 结果),
            cast(bool, 多条)
        )

        self.生成回调结果(事件, 函数返回)

    def _事件_删除文档(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        数据集名称 = 数据.get("数据集名称")
        查询条件 = 数据.get("查询条件")
        多条 = 数据.get("多条", False)
        if not 数据集名称 or not 查询条件:
            self.生成回调结果(事件, 函数通用返回模型(
                状态=函数通用返回模型.失败,
                错误信息="删除文档事件缺失必要参数"
            ))
            self.总线.发布日志("error", f"事件ID:{事件.事件uuid}，缺失参数")
            return
        函数返回 = self.数据库.删除文档(
            cast(str, 数据集名称),
            cast(dict, 查询条件),
            cast(bool, 多条)
        )
        self.生成回调结果(事件, 函数返回)

    # ---------------- 索引操作事件回调 ----------------
    def _事件_创建索引(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        数据集名称 = 数据.get("数据集名称")
        索引字段 = 数据.get("索引字段")
        唯一 = 数据.get("唯一", False)
        if not 数据集名称 or not 索引字段:
            self.生成回调结果(事件, 函数通用返回模型(
                状态=函数通用返回模型.失败,
                错误信息="创建索引事件缺失必要参数"
            ))
            self.总线.发布日志("error", f"事件ID:{事件.事件uuid}，缺失参数")
            return
        函数返回 = self.数据库.创建索引(
            cast(str, 数据集名称),
            cast(List[str], 索引字段),
            cast(bool, 唯一)
        )
        self.生成回调结果(事件, 函数返回)

    def _事件_删除索引(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        数据集名称 = 数据.get("数据集名称")
        索引名称 = 数据.get("索引名称")
        if not 数据集名称 or not 索引名称:
            self.生成回调结果(事件, 函数通用返回模型(
                状态=函数通用返回模型.失败,
                错误信息="删除索引事件缺失必要参数"
            ))
            self.总线.发布日志("error", f"事件ID:{事件.事件uuid}，缺失参数")
            return
        函数返回 = self.数据库.删除索引(cast(str, 数据集名称), cast(str, 索引名称))
        self.生成回调结果(事件, 函数返回)



#----------------------辅助功能----------------------------------
    def _事件_获取合集文档最大序号(self, 数据: Dict[str, Any], 事件: 总线通用事件模型):
        数据集名称 = 数据.get("数据集名称")
        函数返回 = self.数据库.获取合集文档最大序号(数据集名称=数据集名称)
        self.生成回调结果(事件, 函数返回)


